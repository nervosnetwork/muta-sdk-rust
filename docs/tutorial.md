# Tutorial

## A Quick Glance

Muta is a high-performance blockchain framework, aiming to build a high-quality blockchain system. `muta-sdk`is an SDK(Software Development Kit) implemented by Rust, and used to interact with Muta instance. The runnable demo in this tutorial works well in [Rust](https://www.rust-lang.org/) as it is written by Rust, and some structures that need to be explained will be described by Rust interface. It is highly recommended that editing the demo code in [VS Code](https://code.visualstudio.com/), since a modern IDE would be better to help you to auto-complete the code. 

## Dependency

### cargo

```
[dependencies]
muta-sdk = "0.1"
```

## General

```rust
use muta_sdk;

#[tokio::main]
async fn main() {
    let client = muta_sdk::client::client::HttpRpcClient::default();
    let block = client.get_block(None).await.unwrap();
    println("{:?}", block);
}
```

## The Service 

There is a concept called [service](https://docs.muta.dev/#/service_dev) in Muta. Simply said, service is a class composed of multiple methods, so we can call them in the same way.

```json
{
    "serviceName": "the_service_name",
    "method": "the_method_name",
    "payload": "{ \"a_payload_key\": \"a_value\" }"
}
```

- serviceName: a string that means namespace of service, we can think of it as a class
- method: a string that means a method of a service
- payload: a string that means method arguments, in most case, it is a JSON serialized string

Here is a short demo to show how to query balance

```rust
let payload = r#"{"asset_id": "0xf56924db538e77bb5951eb5ff0d02b88983c49c45eea30e8ae3e7234b311436c", "user": "muta14e0lmgck835vm2dfm0w3ckv6svmez8fdgdl705"}"#;
let res = client
    .query_service(
        None,
        None,
        None,
        None,
        "asset".to_owned(),
        "get_balance".to_owned(),
        payload.to_owned(),
    )
    .await
    .unwrap();
println("{:?}", res);
```

## Transaction

When we try to modify the service status, such as transfer, we need to send a signed transaction. A transaction is composed by following structure. We can use the `generate_raw_transaction` to help up to generate a raw(unsigned) transaction

The following code shows how to create a raw transaction, that used to call the asset service for transfer.

```rust
let payload = r#"{"asset_id": "0xf56924db538e77bb5951eb5ff0d02b88983c49c45eea30e8ae3e7234b311436c","to": "muta1tdw5mnyk5s3lngz2mcjd2rse4htrnu6679pr23","value": 1}"#;

let raw_transaction = client
    .generate_raw_transaction(
        "0xb6a4d7da21443f5e816e8700eea87610e6d769657d6b8ec73028457bf2ca4036".to_owned(),
        None,
        None,
        None,
        "muta14e0lmgck835vm2dfm0w3ckv6svmez8fdgdl705".to_owned(),
        "asset".to_owned(),
        "transfer".to_owned(),
        payload.to_owned(),
    )
    .await
    .unwrap();
```

## Signature

Muta will only execute transactions that have been correctly signed. So we need to sign the transaction before we send it.

The private key is essential for the signature process, and it is important to note that the private key should not be known to anyone other than you, otherwise you will be impersonated.

```rust
let account =
    muta_sdk::account::Account::from_hex("0000000000000000000000000000000000000000000000000000000000000001")
        .unwrap();
```

We can sign a transaction in this way

```rust
let signed_transaction = account.sign_raw_tx(raw_transaction).unwrap();
```

The `raw_transaction` was generated by `generate_raw_transaction` that we mentioned above. Next, just send the transaction to Muta, and we'll get a `tx_hash` from the Muta, meaning that the transaction is already known to Muta. 

```rust
let tx_hash = client.send_transaction(signed_transaction).await.unwrap();
```

The transfer wasn't successful until we got the receipt.

```rust
let receipt = client.get_receipt(tx_hash.clone()).await.unwrap();
```




